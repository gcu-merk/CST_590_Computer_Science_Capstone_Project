name: Deploy to Raspberry Pi

on:
  workflow_run:
    workflows: ["Build and Push Docker Image"]
    types:
      - completed
  workflow_dispatch:
    inputs:
      force_deploy:
        description: 'Force deployment regardless of branch'
        required: false
        default: 'false'

env:
  DEPLOY_USER: merk
  DOCKER_IMAGE: gcumerk/cst590-capstone-public:latest
  HOST_UID: 1000
  HOST_GID: 1000
  STORAGE_ROOT: /mnt/storage

jobs:
  validate_deployment:
    name: Validate Deployment Package
    runs-on: ubuntu-latest
    # Only run if the Docker build workflow succeeded
    if: ${{ github.event.workflow_run.conclusion == 'success' }}
    outputs:
      deployment-ready: ${{ steps.validation.outputs.ready }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Set up Docker
        uses: docker/setup-buildx-action@v3
        
      - name: Validate required files
        id: validation
        run: |
          echo "Validating deployment package..."
          required_files=(
            "docker-compose.yml"
            "edge_processing/shared_logging.py"
          )
          missing_files=()
          for file in "${required_files[@]}"; do
            if [ ! -f "$file" ]; then
              missing_files+=("$file")
            fi
          done
          
          if [ ${#missing_files[@]} -gt 0 ]; then
            echo "Missing required files:"
            printf '%s\n' "${missing_files[@]}"
            echo "ready=false" >> $GITHUB_OUTPUT
            exit 1
          fi
          
          # Validate Python syntax for key files
          python3 -m py_compile edge_processing/shared_logging.py
          
          # Validate docker-compose configuration with environment variables
          export HOST_UID=1000
          export HOST_GID=1000
          export STORAGE_ROOT=/mnt/storage
          export DOCKER_IMAGE=gcumerk/cst590-capstone-public:latest
          export REDIS_DATA_PATH=/mnt/storage/redis_data
          export POSTGRES_DATA_PATH=/mnt/storage/postgres_data
          export LOGS_PATH=/mnt/storage/logs
          
          echo "Validating docker-compose configuration..."
          if ! docker compose -f docker-compose.yml config > /dev/null; then
            echo "Invalid docker-compose.yml configuration"
            docker compose -f docker-compose.yml config
            exit 1
          fi
          
          # Verify Redis service exists
          if ! docker compose -f docker-compose.yml config | grep -q "redis:"; then
            echo "Redis service not found in docker-compose.yml"
            exit 1
          fi
          
          # Validate Redis dependencies in requirements files
          echo "Validating Redis dependencies..."
          if ! grep -q "redis" edge_processing/requirements-cloud.txt; then
            echo "Redis not found in edge_processing requirements"
            exit 1
          fi
          
          if ! grep -q "redis" edge_api/requirements.txt; then
            echo "Redis not found in edge_api requirements"
            exit 1
          fi
          
          # Validate network configuration
          if ! docker compose -f docker-compose.yml config | grep -q "app-network"; then
            echo "App network not found in docker-compose.yml"
            exit 1
          fi
          
          echo "ready=true" >> $GITHUB_OUTPUT
          echo "Deployment package validation passed (including Redis and network config)"

  deploy_to_pi:
    name: Deploy to Raspberry Pi
    runs-on: [self-hosted, raspberrypi]
    needs: validate_deployment
    if: needs.validate_deployment.outputs.deployment-ready == 'true'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Prepare deployment staging and persistent directories
        run: |
          echo "Setting up deployment staging and ensuring persistent directories exist..."
          
          # ===== SSD MOUNT VALIDATION =====
          echo "Validating SSD mount at /mnt/storage..."
          
          # Check if /mnt/storage is mounted and accessible
          if ! mountpoint -q /mnt/storage; then
            echo "ERROR: /mnt/storage is not a mount point"
            echo "Available mounts:"
            mount | grep -E "(mnt|storage|ssd)" || true
            echo "Checking /mnt directory:"
            ls -la /mnt/ || true
            echo "The SSD needs to be mounted at /mnt/storage before deployment"
            exit 1
          fi
          
          # Test write access to SSD
          if ! echo "test" > /mnt/storage/.write_test 2>/dev/null; then
            echo "ERROR: Cannot write to /mnt/storage (SSD mount)"
            echo "Mount info:"
            mount | grep /mnt/storage || true
            echo "Permissions:"
            ls -la /mnt/storage || true
            rm -f /mnt/storage/.write_test 2>/dev/null || true
            exit 1
          fi
          rm -f /mnt/storage/.write_test
          echo "âœ“ SSD mount at /mnt/storage is ready and writable"
          
          # ===== DEPLOYMENT STAGING SETUP =====
          echo "Ensuring clean staging environment..."
          
          # Remove existing staging if present
          if [ -d "/mnt/storage/deployment-staging" ]; then
            echo "Removing existing staging directory..."
            if command -v chattr >/dev/null 2>&1; then
              sudo chattr -R -i /mnt/storage/deployment-staging 2>/dev/null || true
            fi
            sudo rm -rf /mnt/storage/deployment-staging
          fi
          
          # Create fresh staging directory
          sudo mkdir -p /mnt/storage/deployment-staging
          sudo chmod 775 /mnt/storage/deployment-staging
          
          # Get current user for proper ownership
          CURRENT_USER=$(whoami)
          CURRENT_GROUP=$(id -gn)
          echo "Setting staging ownership to $CURRENT_USER:$CURRENT_GROUP"
          sudo chown $CURRENT_USER:$CURRENT_GROUP /mnt/storage/deployment-staging
          
          # Verify staging directory is ready
          if [ ! -w "/mnt/storage/deployment-staging" ]; then
            echo "Staging directory not writable by current user"
            echo "Current user: $(whoami)"
            echo "Directory details:"
            ls -la /mnt/storage/deployment-staging
            echo "Attempting to fix permissions..."
            sudo chmod 777 /mnt/storage/deployment-staging
            sudo chown $(whoami):$(id -gn) /mnt/storage/deployment-staging
            if [ ! -w "/mnt/storage/deployment-staging" ]; then
              echo "Failed to fix staging directory permissions"
              exit 1
            fi
          fi
          
          echo "Staging directory prepared: /mnt/storage/deployment-staging"
          
          # ===== PERSISTENT DIRECTORIES =====
          echo "Ensuring persistent application directories exist..."
          
          # Get host user UID/GID for Docker containers
          HOST_UID=$(id -u merk)
          HOST_GID=$(id -g merk)
          echo "Host UID: $HOST_UID, Host GID: $HOST_GID"
          
          # Core application directories
          sudo mkdir -p /mnt/storage/{redis_data,postgres_data,logs,data,config,scripts,backups}
          sudo mkdir -p /mnt/storage/{camera_capture,processed_data,ai_camera_images,periodic_snapshots}
          sudo mkdir -p /mnt/storage/camera_capture/{live,processed,metadata}
          sudo mkdir -p /mnt/storage/logs/{docker,applications,maintenance,system}
          sudo mkdir -p /mnt/storage/database/{backups,schema}
          sudo mkdir -p /mnt/storage/{tmp,cache}
          
          # Container-accessible directories with proper permissions
          sudo mkdir -p /mnt/storage/container-accessible/{redis,postgres,logs,data}
          sudo chmod 777 /mnt/storage/container-accessible /mnt/storage/container-accessible/redis /mnt/storage/container-accessible/postgres /mnt/storage/container-accessible/logs /mnt/storage/container-accessible/data
          sudo chown -R merk:merk /mnt/storage/container-accessible
          
          # Set proper permissions for database directories
          sudo chmod 755 /mnt/storage/redis_data
          sudo chmod 700 /mnt/storage/postgres_data
          sudo chown merk:merk /mnt/storage/redis_data /mnt/storage/postgres_data
          
          # Set permissions for other directories (more permissive for container access)
          sudo chmod 755 /mnt/storage/data /mnt/storage/config /mnt/storage/scripts
          sudo chmod 775 /mnt/storage/logs /mnt/storage/camera_capture /mnt/storage/processed_data /mnt/storage/ai_camera_images /mnt/storage/periodic_snapshots
          sudo chmod 777 /mnt/storage/tmp /mnt/storage/cache /mnt/storage/backups
          sudo chown -R merk:merk /mnt/storage/logs /mnt/storage/camera_capture /mnt/storage/processed_data /mnt/storage/ai_camera_images /mnt/storage/periodic_snapshots /mnt/storage/backups
          sudo chown merk:merk /mnt/storage/data /mnt/storage/config /mnt/storage/scripts /mnt/storage/tmp /mnt/storage/cache
          
          # Specialized service directories
          sudo mkdir -p /mnt/storage/{traffic-monitor-deploy,dht22-weather,data-maintenance,data-consolidator,utils}
          sudo mkdir -p /mnt/storage/traffic-monitor-deploy/{data,config,logs}
          sudo mkdir -p /mnt/storage/dht22-weather/{logs,config}
          sudo chmod 775 /mnt/storage/traffic-monitor-deploy /mnt/storage/dht22-weather
          sudo chmod 775 /mnt/storage/traffic-monitor-deploy/{data,config,logs} /mnt/storage/dht22-weather/{logs,config}
          sudo chmod 770 /mnt/storage/data-maintenance /mnt/storage/data-consolidator /mnt/storage/utils
          sudo chown -R merk:merk /mnt/storage/traffic-monitor-deploy /mnt/storage/dht22-weather /mnt/storage/data-maintenance /mnt/storage/data-consolidator /mnt/storage/utils
          
          echo "All persistent directories ensured"
          
          # ===== COPY FILES TO STAGING =====
          echo "Syncing deployment files to staging..."
          
          # Debug: Check if docker-compose.pi.yml exists before rsync
          echo "Debug: Checking for docker-compose.pi.yml before rsync..."
          if [ -f "docker-compose.pi.yml" ]; then
            echo "âœ“ docker-compose.pi.yml found in source directory"
            ls -la docker-compose*.yml
          else
            echo "âœ— docker-compose.pi.yml NOT found in source directory"
            echo "Current directory: $(pwd)"
            echo "Files in current directory:"
            ls -la
          fi
          
          if ! rsync -avz --delete \
            --exclude='.git*' \
            --exclude='documentation/' \
            --exclude='*.md' \
            --exclude='test_*' \
            --exclude='__pycache__/' \
            ./ /mnt/storage/deployment-staging/; then
            
            echo "rsync failed with exit code $?"
            echo "Staging directory diagnostics:"
            ls -la /mnt/storage/deployment-staging || true
            exit 1
          fi
          
          # Debug: Check if docker-compose.pi.yml exists after rsync
          echo "Debug: Checking for docker-compose.pi.yml after rsync..."
          if [ -f "/mnt/storage/deployment-staging/docker-compose.pi.yml" ]; then
            echo "âœ“ docker-compose.pi.yml found in staging directory"
            ls -la /mnt/storage/deployment-staging/docker-compose*.yml
          else
            echo "âœ— docker-compose.pi.yml NOT found in staging directory"
            echo "Files in staging directory:"
            ls -la /mnt/storage/deployment-staging/ | head -20
          fi
          
          # Create .env file with host UID/GID for Docker Compose
          echo "Creating .env file for Docker UID/GID mapping..."
          cat > /mnt/storage/deployment-staging/.env << EOF
          # Host user mapping for Docker containers
          HOST_UID=${HOST_UID}
          HOST_GID=${HOST_GID}
          DOCKER_USER=${HOST_UID}:${HOST_GID}
          
          # Storage paths
          STORAGE_ROOT=/mnt/storage
          REDIS_DATA_PATH=/mnt/storage/redis_data
          POSTGRES_DATA_PATH=/mnt/storage/postgres_data
          LOGS_PATH=/mnt/storage/logs
          
          # Container-accessible directories
          CONTAINER_ACCESSIBLE_PATH=/mnt/storage/container-accessible
          
          # Docker image from workflow
          DOCKER_IMAGE=${DOCKER_IMAGE}
          
          # Database configuration
          POSTGRES_DB=traffic_monitoring
          POSTGRES_USER=traffic_user
          POSTGRES_PASSWORD=traffic_password
          
          # Redis configuration
          REDIS_HOST=redis
          REDIS_PORT=6379
          
          # API configuration
          API_PORT=5000
          API_HOST=0.0.0.0
          
          # Deployment settings
          COMPOSE_PROJECT_NAME=traffic_monitoring
          DEPLOY_USER=merk
          EOF
          
          echo "Environment file created with UID mapping: $HOST_UID:$HOST_GID"
          
          # Final verification
          echo "Staging ready - directory structure:"
          ls -la /mnt/storage/deployment-staging/ | head -10
          echo "Key persistent directories:"
          ls -la /mnt/storage/ | grep -E "(camera_capture|redis_data|postgres_data|logs|container-accessible)" || true
            
      - name: Execute deployment
        env:
          NON_INTERACTIVE: true
          DEPLOY_USER: ${{ env.DEPLOY_USER }}
          DOCKER_IMAGE: ${{ env.DOCKER_IMAGE }}
          HOST_UID: ${{ env.HOST_UID }}
          HOST_GID: ${{ env.HOST_GID }}
          STORAGE_ROOT: ${{ env.STORAGE_ROOT }}
        run: |
          echo "Executing deployment on Raspberry Pi (self-hosted)..."
          set -e
          
          cd /mnt/storage/deployment-staging
          
          echo "========================================="
          echo "Direct Docker Deployment (No Scripts)"
          echo "========================================="
          
          # Fix missing performance_monitor import issue
          echo "Fixing missing imports in shared_logging..."
          if [ -f "edge_processing/shared_logging.py" ]; then
            # Remove performance_monitor from imports in all service files
            find . -name "*.py" -type f -exec grep -l "performance_monitor" {} \; | while read -r file; do
              echo "Removing performance_monitor import from: $file"
              sed -i 's/, performance_monitor//g' "$file"
              sed -i 's/performance_monitor, //g' "$file"
              sed -i 's/from edge_processing.shared_logging import ServiceLogger, CorrelationContext, performance_monitor/from edge_processing.shared_logging import ServiceLogger, CorrelationContext/g' "$file"
            done
          fi
          
          # Set up proper log directories with correct permissions
          echo "Setting up application log directories..."
          sudo mkdir -p /mnt/storage/logs/applications
          sudo chmod 777 /mnt/storage/logs/applications
          sudo chown -R merk:merk /mnt/storage/logs/applications
          
          # Ensure Redis data directory has correct permissions
          sudo mkdir -p /mnt/storage/redis_data
          sudo chown -R 999:999 /mnt/storage/redis_data
          sudo chmod 755 /mnt/storage/redis_data
          
          # Stop and clean existing containers
          echo "Stopping existing containers..."
          if docker compose ps -q > /dev/null 2>&1; then
            docker compose down --remove-orphans --volumes --timeout 30 || true
          fi
          
          # Clean up any lingering containers by name
          echo "Cleaning up traffic monitoring containers..."
          for container in traffic-monitor redis database-persistence vehicle-consolidator airport-weather dht22-weather data-maintenance radar-service redis-optimization realtime-events-broadcaster nginx-proxy; do
            if docker ps -aq -f name="$container" | grep -q .; then
              echo "Removing container: $container"
              docker stop "$container" 2>/dev/null || true
              docker rm -f "$container" 2>/dev/null || true
            fi
          done
          
          # Clean up networks
          echo "Cleaning up networks..."
          docker network prune -f || true
          
          # Pull latest Docker images
          echo "Pulling Docker images..."
          docker compose pull --ignore-pull-failures || true
          
          # Start services
          echo "Starting Docker services..."
          
          # Start Redis first
          docker compose up -d redis
          echo "Waiting for Redis to be healthy..."
          timeout 60 bash -c 'until docker compose ps redis | grep -q "healthy"; do echo "Waiting for Redis..."; sleep 2; done'
          
          # Start all other services
          echo "Starting all services..."
          if ! docker compose up -d --force-recreate --remove-orphans; then
            echo "Initial startup failed, checking container logs..."
            docker compose logs --tail=20
            
            # Try again with force recreate
            echo "Attempting force recreate..."
            docker compose down --remove-orphans --volumes --timeout 30 || true
            sleep 5
            docker compose up -d --force-recreate --remove-orphans
          fi
          
          echo "Deployment completed successfully"
          
      - name: Validate deployment
        run: |
          echo "Running deployment validation..."
          set -e
          
          cd /mnt/storage/deployment-staging
          
          echo "========================================="
          echo "Validating Traffic Monitoring Deployment"
          echo "========================================="
          
          # Check container status
          echo "Checking container status..."
          docker compose ps
          
          # Verify key services are running
          echo "Verifying critical services..."
          
          # Check Redis
          if docker compose ps redis | grep -q "Up.*healthy"; then
            echo "âœ“ Redis is running and healthy"
          else
            echo "âœ— Redis is not running properly"
            docker compose logs redis --tail=10
          fi
          
          # Check traffic-monitor (API)
          if docker compose ps traffic-monitor | grep -q "Up"; then
            echo "âœ“ Traffic Monitor API is running"
            # Try to reach the health endpoint
            sleep 5  # Give it time to start
            if timeout 10 curl -s http://localhost:5000/health > /dev/null 2>&1; then
              echo "âœ“ API health endpoint is responding"
            else
              echo "âš  API health endpoint not responding yet (may still be starting)"
            fi
          else
            echo "âœ— Traffic Monitor API is not running"
            docker compose logs traffic-monitor --tail=20
          fi
          
          # Check other services
          for service in database-persistence vehicle-consolidator dht22-weather; do
            if docker compose ps "$service" | grep -q "Up"; then
              echo "âœ“ $service is running"
            else
              echo "âš  $service may not be running (checking logs...)"
              docker compose logs "$service" --tail=5
            fi
          done
          
          # Check Redis connectivity
          echo "Testing Redis connectivity..."
          if docker compose exec redis redis-cli ping | grep -q "PONG"; then
            echo "âœ“ Redis is responding to ping"
          else
            echo "âœ— Redis is not responding"
          fi
          
          # Check log directories
          echo "Verifying log directories..."
          if [ -d "/mnt/storage/logs/applications" ] && [ -w "/mnt/storage/logs/applications" ]; then
            echo "âœ“ Application log directory is accessible"
          else
            echo "âœ— Application log directory issue"
            ls -la /mnt/storage/logs/ || true
          fi
          
          # Summary
          echo "========================================="
          echo "Deployment validation completed"
          echo "Check the logs above for any issues"
          echo "========================================="
          
      - name: Cleanup staging files (only on success)
        if: success()
        run: |
          echo "Cleaning up deployment staging directory..."
          sudo rm -rf /mnt/storage/deployment-staging

  notify_status:
    name: Notify Deployment Status
    runs-on: ubuntu-latest
    needs: [validate_deployment, deploy_to_pi]
    if: always()
    steps:
      - name: Deployment Success Notification
        if: needs.deploy_to_pi.result == 'success'
        run: |
          echo "Traffic Monitoring System deployed successfully!"
          echo "Commit: ${{ github.sha }}"
          echo "Triggered by: ${{ github.actor }}"
          echo "Services: Redis, PostgreSQL, Traffic Monitor, Data Maintenance, Weather Services"
          
      - name: Deployment Failure Notification
        if: needs.deploy_to_pi.result == 'failure' || needs.validate_deployment.result == 'failure'
        run: |
          echo "Traffic Monitoring System deployment failed!"
          echo "Environment: production"
          echo "Commit: ${{ github.sha }}"
          echo "Triggered by: ${{ github.actor }}"
          exit 1