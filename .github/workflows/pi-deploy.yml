name: Deploy to Raspberry Pi

on:
  workflow_run:
    workflows: ["Build and Push Docker Image"]
    types:
      - completed
  workflow_dispatch:
    inputs:
      force_deploy:
        description: 'Force deployment regardless of branch'
        required: false
        default: 'false'

env:
  DEPLOY_USER: merk
  DOCKER_IMAGE: gcumerk/cst590-capstone-public:latest
  HOST_UID: 1000
  HOST_GID: 1000
  STORAGE_ROOT: /mnt/storage

jobs:
  validate_deployment:
    name: Validate Deployment Package
    runs-on: ubuntu-latest
    # Only run if the Docker build workflow succeeded
    if: ${{ github.event.workflow_run.conclusion == 'success' }}
    outputs:
      deployment-ready: ${{ steps.validation.outputs.ready }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Set up Docker
        uses: docker/setup-buildx-action@v3
        
      - name: Validate required files
        id: validation
        run: |
          echo "Validating deployment package..."
          required_files=(
            "scripts/host-camera-capture.py"
            "deployment/host-camera-capture.service"
            "deployment/deploy.sh"
            "docker-compose.yml"
          )
          missing_files=()
          for file in "${required_files[@]}"; do
            if [ ! -f "$file" ]; then
              missing_files+=("$file")
            fi
          done
          
          if [ ${#missing_files[@]} -gt 0 ]; then
            echo "Missing required files:"
            printf '%s\n' "${missing_files[@]}"
            echo "ready=false" >> $GITHUB_OUTPUT
            exit 1
          fi
          
          # Validate Python syntax
          python3 -m py_compile scripts/host-camera-capture.py
          
          # Validate docker-compose configuration with environment variables
          export HOST_UID=1000
          export HOST_GID=1000
          export STORAGE_ROOT=/mnt/storage
          export DOCKER_IMAGE=gcumerk/cst590-capstone-public:latest
          export REDIS_DATA_PATH=/mnt/storage/redis_data
          export POSTGRES_DATA_PATH=/mnt/storage/postgres_data
          export LOGS_PATH=/mnt/storage/logs
          
          echo "Validating docker-compose configuration..."
          if ! docker compose -f docker-compose.yml config > /dev/null; then
            echo "Invalid docker-compose.yml configuration"
            docker compose -f docker-compose.yml config
            exit 1
          fi
          
          # Verify Redis service exists
          if ! docker compose -f docker-compose.yml config | grep -q "redis:"; then
            echo "Redis service not found in docker-compose.yml"
            exit 1
          fi
          
          # Validate Redis dependencies in requirements files
          echo "Validating Redis dependencies..."
          if ! grep -q "redis" edge_processing/requirements-cloud.txt; then
            echo "Redis not found in edge_processing requirements"
            exit 1
          fi
          
          if ! grep -q "redis" edge_api/requirements.txt; then
            echo "Redis not found in edge_api requirements"
            exit 1
          fi
          
          # Validate network configuration
          if ! docker compose -f docker-compose.yml config | grep -q "app-network"; then
            echo "App network not found in docker-compose.yml"
            exit 1
          fi
          
          echo "ready=true" >> $GITHUB_OUTPUT
          echo "Deployment package validation passed (including Redis and network config)"

  deploy_to_pi:
    name: Deploy to Raspberry Pi
    runs-on: [self-hosted, raspberrypi]
    needs: validate_deployment
    if: needs.validate_deployment.outputs.deployment-ready == 'true'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Prepare deployment staging and persistent directories
        run: |
          echo "Setting up deployment staging and ensuring persistent directories exist..."
          
          # ===== STORAGE MOUNT VALIDATION =====
          echo "Validating /mnt/storage availability..."
          
          # Ensure /mnt directory exists
          sudo mkdir -p /mnt
          
          # Check if /mnt/storage exists or needs to be created
          if [ ! -d "/mnt/storage" ]; then
            echo "Creating /mnt/storage directory..."
            sudo mkdir -p /mnt/storage
            sudo chmod 755 /mnt/storage
            sudo chown merk:merk /mnt/storage
          fi
          
          # Verify /mnt/storage is writable
          if [ ! -w "/mnt/storage" ]; then
            echo "Making /mnt/storage writable..."
            sudo chmod 775 /mnt/storage
            sudo chown merk:merk /mnt/storage
          fi
          
          # Test write access to /mnt/storage
          echo "Testing write access to /mnt/storage..."
          if ! echo "test" > /mnt/storage/.write_test 2>/dev/null; then
            echo "Cannot write to /mnt/storage, fixing permissions..."
            sudo chmod 777 /mnt/storage
            sudo chown $(whoami):$(id -gn) /mnt/storage
            if ! echo "test" > /mnt/storage/.write_test 2>/dev/null; then
              echo "Failed to establish write access to /mnt/storage"
              echo "Current user: $(whoami)"
              echo "Storage directory info:"
              ls -la /mnt/storage || ls -la /mnt
              exit 1
            fi
          fi
          rm -f /mnt/storage/.write_test
          echo "✓ /mnt/storage is ready and writable"
          
          # ===== DEPLOYMENT STAGING SETUP =====
          echo "Ensuring clean staging environment..."
          
          # Remove existing staging if present
          if [ -d "/mnt/storage/deployment-staging" ]; then
            echo "Removing existing staging directory..."
            if command -v chattr >/dev/null 2>&1; then
              sudo chattr -R -i /mnt/storage/deployment-staging 2>/dev/null || true
            fi
            sudo rm -rf /mnt/storage/deployment-staging
          fi
          
          # Create fresh staging directory
          sudo mkdir -p /mnt/storage/deployment-staging
          sudo chmod 775 /mnt/storage/deployment-staging
          
          # Get current user for proper ownership
          CURRENT_USER=$(whoami)
          CURRENT_GROUP=$(id -gn)
          echo "Setting staging ownership to $CURRENT_USER:$CURRENT_GROUP"
          sudo chown $CURRENT_USER:$CURRENT_GROUP /mnt/storage/deployment-staging
          
          # Verify staging directory is ready
          if [ ! -w "/mnt/storage/deployment-staging" ]; then
            echo "Staging directory not writable by current user"
            echo "Current user: $(whoami)"
            echo "Directory details:"
            ls -la /mnt/storage/deployment-staging
            echo "Attempting to fix permissions..."
            sudo chmod 777 /mnt/storage/deployment-staging
            sudo chown $(whoami):$(id -gn) /mnt/storage/deployment-staging
            if [ ! -w "/mnt/storage/deployment-staging" ]; then
              echo "Failed to fix staging directory permissions"
              exit 1
            fi
          fi
          
          echo "Staging directory prepared: /mnt/storage/deployment-staging"
          
          # ===== PERSISTENT DIRECTORIES =====
          echo "Ensuring persistent application directories exist..."
          
          # Get host user UID/GID for Docker containers
          HOST_UID=$(id -u merk)
          HOST_GID=$(id -g merk)
          echo "Host UID: $HOST_UID, Host GID: $HOST_GID"
          
          # Core application directories
          sudo mkdir -p /mnt/storage/{redis_data,postgres_data,logs,data,config,scripts,backups}
          sudo mkdir -p /mnt/storage/{camera_capture,processed_data,ai_camera_images,periodic_snapshots}
          sudo mkdir -p /mnt/storage/camera_capture/{live,processed,metadata}
          sudo mkdir -p /mnt/storage/logs/{docker,applications,maintenance,system}
          sudo mkdir -p /mnt/storage/database/{backups,schema}
          sudo mkdir -p /mnt/storage/{tmp,cache}
          
          # Container-accessible directories with proper permissions
          sudo mkdir -p /mnt/storage/container-accessible/{redis,postgres,logs,data}
          sudo chmod 777 /mnt/storage/container-accessible /mnt/storage/container-accessible/redis /mnt/storage/container-accessible/postgres /mnt/storage/container-accessible/logs /mnt/storage/container-accessible/data
          sudo chown -R merk:merk /mnt/storage/container-accessible
          
          # Set proper permissions for database directories
          sudo chmod 755 /mnt/storage/redis_data
          sudo chmod 700 /mnt/storage/postgres_data
          sudo chown merk:merk /mnt/storage/redis_data /mnt/storage/postgres_data
          
          # Set permissions for other directories (more permissive for container access)
          sudo chmod 755 /mnt/storage/data /mnt/storage/config /mnt/storage/scripts
          sudo chmod 775 /mnt/storage/logs /mnt/storage/camera_capture /mnt/storage/processed_data /mnt/storage/ai_camera_images /mnt/storage/periodic_snapshots
          sudo chmod 777 /mnt/storage/tmp /mnt/storage/cache /mnt/storage/backups
          sudo chown -R merk:merk /mnt/storage/logs /mnt/storage/camera_capture /mnt/storage/processed_data /mnt/storage/ai_camera_images /mnt/storage/periodic_snapshots /mnt/storage/backups
          sudo chown merk:merk /mnt/storage/data /mnt/storage/config /mnt/storage/scripts /mnt/storage/tmp /mnt/storage/cache
          
          # Specialized service directories
          sudo mkdir -p /mnt/storage/{traffic-monitor-deploy,dht22-weather,data-maintenance,data-consolidator,utils}
          sudo mkdir -p /mnt/storage/traffic-monitor-deploy/{data,config,logs}
          sudo mkdir -p /mnt/storage/dht22-weather/{logs,config}
          sudo chmod 775 /mnt/storage/traffic-monitor-deploy /mnt/storage/dht22-weather
          sudo chmod 775 /mnt/storage/traffic-monitor-deploy/{data,config,logs} /mnt/storage/dht22-weather/{logs,config}
          sudo chmod 770 /mnt/storage/data-maintenance /mnt/storage/data-consolidator /mnt/storage/utils
          sudo chown -R merk:merk /mnt/storage/traffic-monitor-deploy /mnt/storage/dht22-weather /mnt/storage/data-maintenance /mnt/storage/data-consolidator /mnt/storage/utils
          
          echo "All persistent directories ensured"
          
          # ===== COPY FILES TO STAGING =====
          echo "Syncing deployment files to staging..."
          
          # Debug: Check if docker-compose.pi.yml exists before rsync
          echo "Debug: Checking for docker-compose.pi.yml before rsync..."
          if [ -f "docker-compose.pi.yml" ]; then
            echo "✓ docker-compose.pi.yml found in source directory"
            ls -la docker-compose*.yml
          else
            echo "✗ docker-compose.pi.yml NOT found in source directory"
            echo "Current directory: $(pwd)"
            echo "Files in current directory:"
            ls -la
          fi
          
          if ! rsync -avz --delete \
            --exclude='.git*' \
            --exclude='documentation/' \
            --exclude='*.md' \
            --exclude='test_*' \
            --exclude='__pycache__/' \
            ./ /mnt/storage/deployment-staging/; then
            
            echo "rsync failed with exit code $?"
            echo "Staging directory diagnostics:"
            ls -la /mnt/storage/deployment-staging || true
            exit 1
          fi
          
          # Debug: Check if docker-compose.pi.yml exists after rsync
          echo "Debug: Checking for docker-compose.pi.yml after rsync..."
          if [ -f "/mnt/storage/deployment-staging/docker-compose.pi.yml" ]; then
            echo "✓ docker-compose.pi.yml found in staging directory"
            ls -la /mnt/storage/deployment-staging/docker-compose*.yml
          else
            echo "✗ docker-compose.pi.yml NOT found in staging directory"
            echo "Files in staging directory:"
            ls -la /mnt/storage/deployment-staging/ | head -20
          fi
          
          # Create .env file with host UID/GID for Docker Compose
          echo "Creating .env file for Docker UID/GID mapping..."
          cat > /mnt/storage/deployment-staging/.env << EOF
          # Host user mapping for Docker containers
          HOST_UID=${HOST_UID}
          HOST_GID=${HOST_GID}
          DOCKER_USER=${HOST_UID}:${HOST_GID}
          
          # Storage paths
          STORAGE_ROOT=/mnt/storage
          REDIS_DATA_PATH=/mnt/storage/redis_data
          POSTGRES_DATA_PATH=/mnt/storage/postgres_data
          LOGS_PATH=/mnt/storage/logs
          
          # Container-accessible directories
          CONTAINER_ACCESSIBLE_PATH=/mnt/storage/container-accessible
          
          # Docker image from workflow
          DOCKER_IMAGE=${DOCKER_IMAGE}
          
          # Database configuration
          POSTGRES_DB=traffic_monitoring
          POSTGRES_USER=traffic_user
          POSTGRES_PASSWORD=traffic_password
          
          # Redis configuration
          REDIS_HOST=redis
          REDIS_PORT=6379
          
          # API configuration
          API_PORT=5000
          API_HOST=0.0.0.0
          
          # Deployment settings
          COMPOSE_PROJECT_NAME=traffic_monitoring
          DEPLOY_USER=merk
          EOF
          
          echo "Environment file created with UID mapping: $HOST_UID:$HOST_GID"
          
          # Final verification
          echo "Staging ready - directory structure:"
          ls -la /mnt/storage/deployment-staging/ | head -10
          echo "Key persistent directories:"
          ls -la /mnt/storage/ | grep -E "(camera_capture|redis_data|postgres_data|logs|container-accessible)" || true
            
      - name: Execute deployment
        env:
          NON_INTERACTIVE: true
          DEPLOY_USER: ${{ env.DEPLOY_USER }}
          DOCKER_IMAGE: ${{ env.DOCKER_IMAGE }}
          HOST_UID: ${{ env.HOST_UID }}
          HOST_GID: ${{ env.HOST_GID }}
          STORAGE_ROOT: ${{ env.STORAGE_ROOT }}
        run: |
          echo "Executing deployment on Raspberry Pi (self-hosted)..."
          set -e
          
          cd /mnt/storage/deployment-staging
          
          # Validate deployment script exists
          if [ ! -f "deployment/deploy.sh" ]; then
            echo "Deploy script not found: deployment/deploy.sh"
            exit 1
          fi
          
          sudo chmod +x deployment/deploy.sh
          
          # Execute deployment script and capture exit code
          if sudo -E ./deployment/deploy.sh 2>&1 | tee deployment.log; then
            echo "Deployment script completed successfully"
            echo "Full deployment log:"
            cat deployment.log
          else
            echo "Deployment script failed with exit code $?"
            echo "Last 50 lines of deployment log:"
            tail -50 deployment.log || true
            exit 1
          fi
          
      - name: Validate deployment
        run: |
          echo "Running deployment validation from staging..."
          set -e
          
          # Ensure we're in the staging directory
          cd /mnt/storage/deployment-staging
          echo "Validation working directory: $(pwd)"
          
          # Check if validation script exists
          if [ ! -f "deployment/validate_deployment.sh" ]; then
            echo "Validation script not found: deployment/validate_deployment.sh"
            echo "Skipping validation step"
          else
            echo "Debug: Checking for docker-compose.pi.yml in staging directory..."
            ls -la docker-compose*.yml || echo "No docker-compose files found"
            pwd
            echo "Contents of staging directory:"
            ls -la
            echo "Debug: Checking validation script version..."
            head -10 deployment/validate_deployment.sh
            echo "Debug: Running validation script from staging directory..."
            sudo chmod +x deployment/validate_deployment.sh
            
            # Run validation script with explicit working directory
            (cd /mnt/storage/deployment-staging && sudo ./deployment/validate_deployment.sh)
          fi
          
      - name: Cleanup staging files (only on success)
        if: success()
        run: |
          echo "Cleaning up deployment staging directory..."
          sudo rm -rf /mnt/storage/deployment-staging

  notify_status:
    name: Notify Deployment Status
    runs-on: ubuntu-latest
    needs: [validate_deployment, deploy_to_pi]
    if: always()
    steps:
      - name: Deployment Success Notification
        if: needs.deploy_to_pi.result == 'success'
        run: |
          echo "Traffic Monitoring System deployed successfully!"
          echo "Commit: ${{ github.sha }}"
          echo "Triggered by: ${{ github.actor }}"
          echo "Services: Redis, PostgreSQL, Traffic Monitor, Data Maintenance, Weather Services"
          
      - name: Deployment Failure Notification
        if: needs.deploy_to_pi.result == 'failure' || needs.validate_deployment.result == 'failure'
        run: |
          echo "Traffic Monitoring System deployment failed!"
          echo "Environment: production"
          echo "Commit: ${{ github.sha }}"
          echo "Triggered by: ${{ github.actor }}"
          exit 1