name: Deploy to Raspberry Pi

on:
  workflow_run:
    workflows: ["Build and Push Docker Image"]
    types:
      - completed
  workflow_dispatch:
    inputs:
      force_deploy:
        description: 'Force deployment regardless of branch'
        required: false
        default: 'false'

env:
  DEPLOY_USER: merk
  DOCKER_IMAGE: gcumerk/cst590-capstone-public:latest
  HOST_UID: 1000
  HOST_GID: 1000
  STORAGE_ROOT: /mnt/storage

jobs:
  validate_deployment:
    name: Validate Deployment Package
    runs-on: ubuntu-latest
    # Only run if the Docker build workflow succeeded
    if: ${{ github.event.workflow_run.conclusion == 'success' }}
    outputs:
      deployment-ready: ${{ steps.validation.outputs.ready }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Set up Docker
        uses: docker/setup-buildx-action@v3
        
      - name: Validate required files
        id: validation
        run: |
          echo "Validating deployment package..."
          required_files=(
            "docker-compose.yml"
            "edge_processing/shared_logging.py"
          )
          missing_files=()
          for file in "${required_files[@]}"; do
            if [ ! -f "$file" ]; then
              missing_files+=("$file")
            fi
          done
          
          if [ ${#missing_files[@]} -gt 0 ]; then
            echo "Missing required files:"
            printf '%s\n' "${missing_files[@]}"
            echo "ready=false" >> $GITHUB_OUTPUT
            exit 1
          fi
          
          # Validate Python syntax for key files
          python3 -m py_compile edge_processing/shared_logging.py
          
          # Validate docker-compose configuration with environment variables
          export HOST_UID=1000
          export HOST_GID=1000
          export STORAGE_ROOT=/mnt/storage
          export DOCKER_IMAGE=gcumerk/cst590-capstone-public:latest
          export REDIS_DATA_PATH=/mnt/storage/redis_data
          export POSTGRES_DATA_PATH=/mnt/storage/postgres_data
          export LOGS_PATH=/mnt/storage/logs
          
          echo "Validating docker-compose configuration..."
          if ! docker compose -f docker-compose.yml config > /dev/null; then
            echo "Invalid docker-compose.yml configuration"
            docker compose -f docker-compose.yml config
            exit 1
          fi
          
          # Verify Redis service exists
          if ! docker compose -f docker-compose.yml config | grep -q "redis:"; then
            echo "Redis service not found in docker-compose.yml"
            exit 1
          fi
          
          # Validate Redis dependencies in requirements files
          echo "Validating Redis dependencies..."
          if ! grep -q "redis" edge_processing/requirements-cloud.txt; then
            echo "Redis not found in edge_processing requirements"
            exit 1
          fi
          
          if ! grep -q "redis" edge_api/requirements.txt; then
            echo "Redis not found in edge_api requirements"
            exit 1
          fi
          
          # Validate network configuration
          if ! docker compose -f docker-compose.yml config | grep -q "app-network"; then
            echo "App network not found in docker-compose.yml"
            exit 1
          fi
          
          echo "ready=true" >> $GITHUB_OUTPUT
          echo "Deployment package validation passed (including Redis and network config)"

  deploy_to_pi:
    name: Deploy to Raspberry Pi
    runs-on: [self-hosted, raspberrypi]
    needs: validate_deployment
    if: needs.validate_deployment.outputs.deployment-ready == 'true'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Prepare deployment staging and persistent directories
        run: |
          echo "Setting up deployment staging and ensuring persistent directories exist..."
          
          # ===== SSD MOUNT VALIDATION =====
          echo "Validating SSD mount at /mnt/storage..."
          
          # Check if /mnt/storage is mounted and accessible
          if ! mountpoint -q /mnt/storage; then
            echo "ERROR: /mnt/storage is not a mount point"
            echo "Available mounts:"
            mount | grep -E "(mnt|storage|ssd)" || true
            echo "Checking /mnt directory:"
            ls -la /mnt/ || true
            echo "The SSD needs to be mounted at /mnt/storage before deployment"
            exit 1
          fi
          
          # Test write access to SSD
          if ! echo "test" > /mnt/storage/.write_test 2>/dev/null; then
            echo "ERROR: Cannot write to /mnt/storage (SSD mount)"
            echo "Mount info:"
            mount | grep /mnt/storage || true
            echo "Permissions:"
            ls -la /mnt/storage || true
            rm -f /mnt/storage/.write_test 2>/dev/null || true
            exit 1
          fi
          rm -f /mnt/storage/.write_test
          echo "✓ SSD mount at /mnt/storage is ready and writable"
          
          # ===== DEPLOYMENT STAGING SETUP =====
          echo "Ensuring clean staging environment..."
          
          # Remove existing staging if present
          if [ -d "/mnt/storage/deployment-staging" ]; then
            echo "Removing existing staging directory..."
            if command -v chattr >/dev/null 2>&1; then
              sudo chattr -R -i /mnt/storage/deployment-staging 2>/dev/null || true
            fi
            sudo rm -rf /mnt/storage/deployment-staging
          fi
          
          # Create fresh staging directory
          sudo mkdir -p /mnt/storage/deployment-staging
          sudo chmod 775 /mnt/storage/deployment-staging
          
          # Get current user for proper ownership
          CURRENT_USER=$(whoami)
          CURRENT_GROUP=$(id -gn)
          echo "Setting staging ownership to $CURRENT_USER:$CURRENT_GROUP"
          sudo chown $CURRENT_USER:$CURRENT_GROUP /mnt/storage/deployment-staging
          
          # Verify staging directory is ready
          if [ ! -w "/mnt/storage/deployment-staging" ]; then
            echo "Staging directory not writable by current user"
            echo "Current user: $(whoami)"
            echo "Directory details:"
            ls -la /mnt/storage/deployment-staging
            echo "Attempting to fix permissions..."
            sudo chmod 777 /mnt/storage/deployment-staging
            sudo chown $(whoami):$(id -gn) /mnt/storage/deployment-staging
            if [ ! -w "/mnt/storage/deployment-staging" ]; then
              echo "Failed to fix staging directory permissions"
              exit 1
            fi
          fi
          
          echo "Staging directory prepared: /mnt/storage/deployment-staging"
          
          # ===== PERSISTENT DIRECTORIES =====
          echo "Ensuring persistent application directories exist..."
          
          # Get host user UID/GID for Docker containers
          HOST_UID=$(id -u merk)
          HOST_GID=$(id -g merk)
          echo "Host UID: $HOST_UID, Host GID: $HOST_GID"
          
          # Core application directories
          sudo mkdir -p /mnt/storage/{redis_data,postgres_data,logs,data,config,scripts,backups}
          sudo mkdir -p /mnt/storage/{camera_capture,processed_data,ai_camera_images,periodic_snapshots}
          sudo mkdir -p /mnt/storage/camera_capture/{live,processed,metadata}
          sudo mkdir -p /mnt/storage/logs/{docker,applications,maintenance,system}
          sudo mkdir -p /mnt/storage/database/{backups,schema}
          sudo mkdir -p /mnt/storage/{tmp,cache}
          
          # Container-accessible directories with proper permissions
          sudo mkdir -p /mnt/storage/container-accessible/{redis,postgres,logs,data}
          sudo chmod 777 /mnt/storage/container-accessible /mnt/storage/container-accessible/redis /mnt/storage/container-accessible/postgres /mnt/storage/container-accessible/logs /mnt/storage/container-accessible/data
          sudo chown -R merk:merk /mnt/storage/container-accessible
          
          # Set proper permissions for database directories
          sudo chmod 755 /mnt/storage/redis_data
          sudo chmod 700 /mnt/storage/postgres_data
          sudo chown merk:merk /mnt/storage/redis_data /mnt/storage/postgres_data
          
          # Set permissions for other directories (more permissive for container access)
          sudo chmod 755 /mnt/storage/data /mnt/storage/config /mnt/storage/scripts
          sudo chmod 775 /mnt/storage/logs /mnt/storage/camera_capture /mnt/storage/processed_data /mnt/storage/ai_camera_images /mnt/storage/periodic_snapshots
          sudo chmod 777 /mnt/storage/tmp /mnt/storage/cache /mnt/storage/backups
          sudo chown -R merk:merk /mnt/storage/logs /mnt/storage/camera_capture /mnt/storage/processed_data /mnt/storage/ai_camera_images /mnt/storage/periodic_snapshots /mnt/storage/backups
          sudo chown merk:merk /mnt/storage/data /mnt/storage/config /mnt/storage/scripts /mnt/storage/tmp /mnt/storage/cache
          
          # Specialized service directories
          sudo mkdir -p /mnt/storage/{traffic-monitor-deploy,dht22-weather,data-maintenance,data-consolidator,utils}
          sudo mkdir -p /mnt/storage/traffic-monitor-deploy/{data,config,logs}
          sudo mkdir -p /mnt/storage/dht22-weather/{logs,config}
          sudo chmod 775 /mnt/storage/traffic-monitor-deploy /mnt/storage/dht22-weather
          sudo chmod 775 /mnt/storage/traffic-monitor-deploy/{data,config,logs} /mnt/storage/dht22-weather/{logs,config}
          sudo chmod 770 /mnt/storage/data-maintenance /mnt/storage/data-consolidator /mnt/storage/utils
          sudo chown -R merk:merk /mnt/storage/traffic-monitor-deploy /mnt/storage/dht22-weather /mnt/storage/data-maintenance /mnt/storage/data-consolidator /mnt/storage/utils
          
          echo "All persistent directories ensured"
          
          # ===== COPY FILES TO STAGING =====
          echo "Syncing deployment files to staging..."
          
          # Debug: Check if docker-compose.pi.yml exists before rsync
          echo "Debug: Checking for docker-compose.pi.yml before rsync..."
          if [ -f "docker-compose.pi.yml" ]; then
            echo "✓ docker-compose.pi.yml found in source directory"
            ls -la docker-compose*.yml
          else
            echo "✗ docker-compose.pi.yml NOT found in source directory"
            echo "Current directory: $(pwd)"
            echo "Files in current directory:"
            ls -la
          fi
          
          if ! rsync -avz --delete \
            --exclude='.git*' \
            --exclude='documentation/' \
            --exclude='*.md' \
            --exclude='test_*' \
            --exclude='__pycache__/' \
            ./ /mnt/storage/deployment-staging/; then
            
            echo "rsync failed with exit code $?"
            echo "Staging directory diagnostics:"
            ls -la /mnt/storage/deployment-staging || true
            exit 1
          fi
          
          # Debug: Check if docker-compose.pi.yml exists after rsync
          echo "Debug: Checking for docker-compose.pi.yml after rsync..."
          if [ -f "/mnt/storage/deployment-staging/docker-compose.pi.yml" ]; then
            echo "✓ docker-compose.pi.yml found in staging directory"
            ls -la /mnt/storage/deployment-staging/docker-compose*.yml
          else
            echo "✗ docker-compose.pi.yml NOT found in staging directory"
            echo "Files in staging directory:"
            ls -la /mnt/storage/deployment-staging/ | head -20
          fi
          
          # Create .env file with host UID/GID for Docker Compose
          echo "Creating .env file for Docker UID/GID mapping..."
          cat > /mnt/storage/deployment-staging/.env << EOF
          # Host user mapping for Docker containers
          HOST_UID=${HOST_UID}
          HOST_GID=${HOST_GID}
          DOCKER_USER=${HOST_UID}:${HOST_GID}
          
          # Storage paths
          STORAGE_ROOT=/mnt/storage
          REDIS_DATA_PATH=/mnt/storage/redis_data
          POSTGRES_DATA_PATH=/mnt/storage/postgres_data
          LOGS_PATH=/mnt/storage/logs
          
          # Container-accessible directories
          CONTAINER_ACCESSIBLE_PATH=/mnt/storage/container-accessible
          
          # Docker image from workflow
          DOCKER_IMAGE=${DOCKER_IMAGE}
          
          # Database configuration
          POSTGRES_DB=traffic_monitoring
          POSTGRES_USER=traffic_user
          POSTGRES_PASSWORD=traffic_password
          
          # Redis configuration
          REDIS_HOST=redis
          REDIS_PORT=6379
          
          # API configuration
          API_PORT=5000
          API_HOST=0.0.0.0
          
          # Deployment settings
          COMPOSE_PROJECT_NAME=traffic_monitoring
          DEPLOY_USER=merk
          EOF
          
          echo "Environment file created with UID mapping: $HOST_UID:$HOST_GID"
          
          # Final verification
          echo "Staging ready - directory structure:"
          ls -la /mnt/storage/deployment-staging/ | head -10
          echo "Key persistent directories:"
          ls -la /mnt/storage/ | grep -E "(camera_capture|redis_data|postgres_data|logs|container-accessible)" || true
            
      - name: Execute deployment
        env:
          NON_INTERACTIVE: true
          DEPLOY_USER: ${{ env.DEPLOY_USER }}
          DOCKER_IMAGE: ${{ env.DOCKER_IMAGE }}
          HOST_UID: ${{ env.HOST_UID }}
          HOST_GID: ${{ env.HOST_GID }}
          STORAGE_ROOT: ${{ env.STORAGE_ROOT }}
        run: |
          echo "Executing deployment on Raspberry Pi (self-hosted)..."
          set -e
          
          cd /mnt/storage/deployment-staging
          
          echo "========================================="
          echo "Direct Docker Deployment (No Scripts)"
          echo "========================================="
          
          # Fix missing performance_monitor import issue
          echo "Fixing missing imports in shared_logging..."
          if [ -f "edge_processing/shared_logging.py" ]; then
            # Remove performance_monitor from imports in all service files
            find . -name "*.py" -type f -exec grep -l "performance_monitor" {} \; | while read -r file; do
              echo "Removing performance_monitor import from: $file"
              sed -i 's/, performance_monitor//g' "$file"
              sed -i 's/performance_monitor, //g' "$file"
              sed -i 's/from edge_processing.shared_logging import ServiceLogger, CorrelationContext, performance_monitor/from edge_processing.shared_logging import ServiceLogger, CorrelationContext/g' "$file"
            done
          fi
          
          # Set up proper log directories with correct permissions
          echo "Setting up application log directories..."
          sudo mkdir -p /mnt/storage/logs/applications
          sudo chmod 777 /mnt/storage/logs/applications
          sudo chown -R merk:merk /mnt/storage/logs/applications
          
          # Ensure Redis data directory has correct permissions
          sudo mkdir -p /mnt/storage/redis_data
          sudo chown -R 999:999 /mnt/storage/redis_data
          sudo chmod 755 /mnt/storage/redis_data
          
          # Stop and clean existing containers
          echo "Stopping existing containers..."
          if docker compose ps -q > /dev/null 2>&1; then
            docker compose down --remove-orphans --volumes --timeout 30 || true
          fi
          
          # Clean up any lingering containers by name
          echo "Cleaning up traffic monitoring containers..."
          for container in traffic-monitor redis database-persistence vehicle-consolidator airport-weather dht22-weather data-maintenance radar-service redis-optimization realtime-events-broadcaster nginx-proxy; do
            if docker ps -aq -f name="$container" | grep -q .; then
              echo "Removing container: $container"
              docker stop "$container" 2>/dev/null || true
              docker rm -f "$container" 2>/dev/null || true
            fi
          done
          
          # Clean up networks
          echo "Cleaning up networks..."
          docker network prune -f || true
          
          # Pull latest Docker images
          echo "Pulling Docker images..."
          docker compose pull --ignore-pull-failures || true
          
          # Start services
          echo "Starting Docker services..."
          
          # Start Redis first
          docker compose up -d redis
          echo "Waiting for Redis to be healthy..."
          timeout 60 bash -c 'until docker compose ps redis | grep -q "healthy"; do echo "Waiting for Redis..."; sleep 2; done'
          
          # Start all other services
          echo "Starting all services..."
          if ! docker compose up -d --force-recreate --remove-orphans; then
            echo "Initial startup failed, checking container logs..."
            docker compose logs --tail=20
            
            # Try again with force recreate
            echo "Attempting force recreate..."
            docker compose down --remove-orphans --volumes --timeout 30 || true
            sleep 5
            docker compose up -d --force-recreate --remove-orphans
          fi
          
          echo "Deployment completed successfully"
          
      - name: Validate deployment
        run: |
          echo "Running deployment validation..."
          set -e
          
          cd /mnt/storage/deployment-staging
          
          echo "========================================="
          echo "Validating Traffic Monitoring Deployment"
          echo "========================================="
          
          # Check container status
          echo "Checking container status..."
          docker compose ps
          
          # Verify key services are running
          echo "Verifying critical services..."
          
          # Check Redis
          if docker compose ps redis | grep -q "Up.*healthy"; then
            echo "✓ Redis is running and healthy"
          else
            echo "✗ Redis is not running properly"
            docker compose logs redis --tail=10
          fi
          
          # Check traffic-monitor (API)
          if docker compose ps traffic-monitor | grep -q "Up"; then
            echo "✓ Traffic Monitor API is running"
            # Try to reach the health endpoint
            sleep 5  # Give it time to start
            if timeout 10 curl -s http://localhost:5000/health > /dev/null 2>&1; then
              echo "✓ API health endpoint is responding"
            else
              echo "⚠ API health endpoint not responding yet (may still be starting)"
            fi
          else
            echo "✗ Traffic Monitor API is not running"
            docker compose logs traffic-monitor --tail=20
          fi
          
          # Check other services
          for service in database-persistence vehicle-consolidator dht22-weather; do
            if docker compose ps "$service" | grep -q "Up"; then
              echo "✓ $service is running"
            else
              echo "⚠ $service may not be running (checking logs...)"
              docker compose logs "$service" --tail=5
            fi
          done
          
          # Check Redis connectivity
          echo "Testing Redis connectivity..."
          if docker compose exec redis redis-cli ping | grep -q "PONG"; then
            echo "✓ Redis is responding to ping"
          else
            echo "✗ Redis is not responding"
          fi
          
          # Check log directories
          echo "Verifying log directories..."
          if [ -d "/mnt/storage/logs/applications" ] && [ -w "/mnt/storage/logs/applications" ]; then
            echo "✓ Application log directory is accessible"
          else
            echo "✗ Application log directory issue"
            ls -la /mnt/storage/logs/ || true
          fi
          
          # Summary
          echo "========================================="
          echo "Deployment validation completed"
          echo "Check the logs above for any issues"
          echo "========================================="
          
      - name: Cleanup staging files (only on success)
        if: success()
        run: |
          echo "Cleaning up deployment staging directory..."
          sudo rm -rf /mnt/storage/deployment-staging

  notify_status:
    name: Notify Deployment Status
    runs-on: ubuntu-latest
    needs: [validate_deployment, deploy_to_pi]
    if: always()
    steps:
      - name: Deployment Success Notification
        if: needs.deploy_to_pi.result == 'success'
        run: |
          echo "Traffic Monitoring System deployed successfully!"
          echo "Commit: ${{ github.sha }}"
          echo "Triggered by: ${{ github.actor }}"
          echo "Services: Redis, PostgreSQL, Traffic Monitor, Data Maintenance, Weather Services"
          
      - name: Deployment Failure Notification
        if: needs.deploy_to_pi.result == 'failure' || needs.validate_deployment.result == 'failure'
        run: |
          echo "Traffic Monitoring System deployment failed!"
          echo "Environment: production"
          echo "Commit: ${{ github.sha }}"
          echo "Triggered by: ${{ github.actor }}"
          exit 1