name: Deploy to Raspberry Pi

on:
  workflow_run:
    workflows: ["Build and Push Docker Image"]
    types:
      - completed
  workflow_dispatch:
    inputs:
      force_deploy:
        description: 'Force deployment regardless of branch'
        required: false
        default: 'false'

env:
  DEPLOY_USER: merk
  DOCKER_IMAGE: gcumerk/cst590-capstone-public:latest

jobs:
  validate_deployment:
    name: Validate Deployment Package
    runs-on: ubuntu-latest
    outputs:
      deployment-ready: ${{ steps.validation.outputs.ready }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Set up Docker
        uses: docker/setup-buildx-action@v3
        
      - name: Validate required files
        id: validation
        run: |
          echo "Validating deployment package..."
          required_files=(
            "scripts/host-camera-capture.py"
            "deployment/host-camera-capture.service"
            "deployment/deploy.sh"
            "docker-compose.yml"
            "docker-compose.pi.yml"
          )
          missing_files=()
          for file in "${required_files[@]}"; do
            if [ ! -f "$file" ]; then
              missing_files+=("$file")
            fi
          done
          
          if [ ${#missing_files[@]} -gt 0 ]; then
            echo "Missing required files:"
            printf '%s\n' "${missing_files[@]}"
            echo "ready=false" >> $GITHUB_OUTPUT
            exit 1
          fi
          
          python3 -m py_compile scripts/host-camera-capture.py
          
          echo "Validating docker-compose configuration..."
          docker compose -f docker-compose.yml config > /dev/null
          
          if ! docker compose -f docker-compose.yml config | grep -q "redis:"; then
            echo "❌ Redis service not found in docker-compose.yml"
            exit 1
          fi
          
          echo "Validating Redis dependencies..."
          if ! grep -q "redis" edge_processing/requirements-cloud.txt; then
            echo "❌ Redis not found in edge_processing requirements"
            exit 1
          fi
          
          echo "ready=true" >> $GITHUB_OUTPUT
          echo "✅ Deployment package validation passed (including Redis)"

  deploy_to_pi:
    name: Deploy to Raspberry Pi
    # Require a self-hosted runner with the 'raspberrypi' label so these
    # steps (creating /mnt/storage, rsync, docker-compose, systemctl checks)
    # only run on the Raspberry Pi runner and not on other self-hosted machines.
    runs-on: [self-hosted, raspberrypi]
    needs: validate_deployment
    if: needs.validate_deployment.outputs.deployment-ready == 'true'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Prepare deployment staging and persistent directories
        run: |
          echo "📦 Setting up deployment staging and ensuring persistent directories exist..."
          
          # ===== DEPLOYMENT STAGING SETUP (simplified) =====
          echo "🧹 Ensuring clean staging environment..."
          
          # Remove existing staging if present (with attribute cleanup)
          if [ -d "/mnt/storage/deployment-staging" ]; then
            echo "Removing existing staging directory..."
            if command -v chattr >/dev/null 2>&1; then
              sudo chattr -R -i /mnt/storage/deployment-staging 2>/dev/null || true
            fi
            sudo rm -rf /mnt/storage/deployment-staging
          fi
          
          # Create fresh staging directory
          sudo mkdir -p /mnt/storage/deployment-staging
          sudo chmod 755 /mnt/storage/deployment-staging
          sudo chown merk:merk /mnt/storage/deployment-staging
          
          # Verify staging directory is ready
          if [ ! -w "/mnt/storage/deployment-staging" ]; then
            echo "❌ Staging directory not writable by current user"
            ls -la /mnt/storage/deployment-staging
            exit 1
          fi
          
          echo "✅ Staging directory prepared: /mnt/storage/deployment-staging"
          
          # ===== PERSISTENT DIRECTORIES (your existing structure) =====
          echo "📁 Ensuring persistent application directories exist..."
          
          # DHT22 weather service directory
          sudo mkdir -p /mnt/storage/dht22-weather/{logs,config}
          sudo chmod 755 /mnt/storage/dht22-weather /mnt/storage/dht22-weather/logs /mnt/storage/dht22-weather/config
          sudo chown -R merk:merk /mnt/storage/dht22-weather
          
          # Camera capture directories
          sudo mkdir -p /mnt/storage/camera_capture/{live,processed,metadata}
          sudo chmod 775 /mnt/storage/camera_capture /mnt/storage/camera_capture/live /mnt/storage/camera_capture/processed /mnt/storage/camera_capture/metadata
          sudo chown -R merk:merk /mnt/storage/camera_capture
          
          # Get host user UID/GID for Docker containers
          HOST_UID=$(id -u merk)
          HOST_GID=$(id -g merk)
          echo "Host UID: $HOST_UID, Host GID: $HOST_GID"
          
          # AI and processing directories
          sudo mkdir -p /mnt/storage/{periodic_snapshots,ai_camera_images,processed_data}
          sudo chmod 775 /mnt/storage/periodic_snapshots /mnt/storage/ai_camera_images /mnt/storage/processed_data
          sudo chown merk:merk /mnt/storage/periodic_snapshots /mnt/storage/ai_camera_images /mnt/storage/processed_data
          
          # Traffic monitor deployment
          sudo mkdir -p /mnt/storage/traffic-monitor-deploy
          sudo chmod 755 /mnt/storage/traffic-monitor-deploy
          sudo chown merk:merk /mnt/storage/traffic-monitor-deploy
          
          # Database directories (with proper container access)
          sudo mkdir -p /mnt/storage/database/{backups,schema}
          sudo chmod 775 /mnt/storage/database /mnt/storage/database/backups /mnt/storage/database/schema
          sudo chown -R merk:merk /mnt/storage/database
          
          # Logging directories (container-accessible)
          sudo mkdir -p /mnt/storage/logs/{docker,applications,maintenance,system}
          sudo chmod 775 /mnt/storage/logs /mnt/storage/logs/docker /mnt/storage/logs/applications /mnt/storage/logs/maintenance /mnt/storage/logs/system
          sudo chown -R merk:merk /mnt/storage/logs
          
          # Redis and database data (critical for container access)
          sudo mkdir -p /mnt/storage/redis_data /mnt/storage/postgres_data
          sudo chmod 755 /mnt/storage/redis_data
          sudo chmod 700 /mnt/storage/postgres_data
          sudo chown merk:merk /mnt/storage/redis_data /mnt/storage/postgres_data
          
          # For containers that need to write as different users, create docker-accessible versions
          # This ensures container processes can access these directories
          sudo mkdir -p /mnt/storage/container-accessible/{redis,postgres,logs,data}
          sudo chmod 777 /mnt/storage/container-accessible /mnt/storage/container-accessible/redis /mnt/storage/container-accessible/postgres /mnt/storage/container-accessible/logs /mnt/storage/container-accessible/data
          sudo chown -R merk:merk /mnt/storage/container-accessible
          
          # Generic directories
          sudo mkdir -p /mnt/storage/{data,config,scripts,backups}
          sudo chmod 755 /mnt/storage/data /mnt/storage/config /mnt/storage/scripts
          sudo chmod 775 /mnt/storage/backups
          sudo chown merk:merk /mnt/storage/data /mnt/storage/config /mnt/storage/scripts /mnt/storage/backups
          
          # Temporary directories
          sudo mkdir -p /mnt/storage/{tmp,cache}
          sudo chmod 777 /mnt/storage/tmp /mnt/storage/cache
          sudo chown merk:merk /mnt/storage/tmp /mnt/storage/cache
          
          # Data collection services
          sudo mkdir -p /mnt/storage/{data-maintenance,data-consolidator,utils}
          sudo chmod 770 /mnt/storage/data-maintenance /mnt/storage/data-consolidator /mnt/storage/utils
          sudo chown merk:merk /mnt/storage/data-maintenance /mnt/storage/data-consolidator /mnt/storage/utils
          
          # Specialized data collection
          sudo mkdir -p /mnt/storage/{license-plate-data-collection,speed-data-collection,stop-sign-data-collection}
          sudo chmod 770 /mnt/storage/license-plate-data-collection /mnt/storage/speed-data-collection /mnt/storage/stop-sign-data-collection
          sudo chown merk:merk /mnt/storage/license-plate-data-collection /mnt/storage/speed-data-collection /mnt/storage/stop-sign-data-collection
          
          echo "✅ All persistent directories ensured"
          
          # ===== COPY FILES TO STAGING =====
          echo "🔄 Syncing deployment files to staging..."
          
          if ! rsync -avz --delete \
            --exclude='.git*' \
            --exclude='documentation/' \
            --exclude='*.md' \
            --exclude='test_*' \
            --exclude='__pycache__/' \
            ./ /mnt/storage/deployment-staging/; then
            
            echo "❌ rsync failed with exit code $?"
            echo "🔎 Staging directory diagnostics:"
            ls -la /mnt/storage/deployment-staging || true
            exit 1
          fi
          
          # Final verification
          echo "📋 Staging ready - directory structure:"
          ls -la /mnt/storage/deployment-staging/ | head -10
          echo "📋 Key persistent directories:"
          ls -la /mnt/storage/ | grep -E "(camera_capture|redis_data|logs|database)" || true
          
          # Create .env file with host UID/GID for Docker Compose
          echo "🔧 Creating .env file for Docker UID/GID mapping..."
          cat > /mnt/storage/deployment-staging/.env << EOF
          # Host user mapping for Docker containers
          HOST_UID=${HOST_UID}
          HOST_GID=${HOST_GID}
          DOCKER_USER=${HOST_UID}:${HOST_GID}
          
          # Storage paths
          STORAGE_ROOT=/mnt/storage
          
          # Container-accessible directories
          REDIS_DATA_PATH=/mnt/storage/container-accessible/redis
          POSTGRES_DATA_PATH=/mnt/storage/container-accessible/postgres  
          LOGS_PATH=/mnt/storage/container-accessible/logs
          
          # Docker image from workflow
          DOCKER_IMAGE=${DOCKER_IMAGE}
          EOF
          
          echo "✅ Environment file created with UID mapping: $HOST_UID:$HOST_GID"
            
      - name: Execute deployment
        run: |
          echo "🚀 Executing deployment on Raspberry Pi (self-hosted)..."
          set -e
          
          cd /mnt/storage/deployment-staging
          
          # Validate deployment script exists
          if [ ! -f "deployment/deploy.sh" ]; then
            echo "❌ Deploy script not found: deployment/deploy.sh"
            exit 1
          fi
          
          sudo chmod +x deployment/deploy.sh
          
          # Execute deployment script and capture exit code
          if sudo ./deployment/deploy.sh 2>&1 | tee deployment.log; then
            echo "✅ Deployment script completed successfully"
          else
            echo "❌ Deployment script failed with exit code $?"
            echo "📋 Last 50 lines of deployment log:"
            tail -50 deployment.log || true
            exit 1
          fi
          
      - name: Validate deployment (run host-side script)
        run: |
          echo "🔍 Running host-side validation script from staging..."
          set -e
          cd /mnt/storage/deployment-staging
          
          # Check if validation script exists
          if [ ! -f "deployment/validate_deployment.sh" ]; then
            echo "⚠️ Validation script not found: deployment/validate_deployment.sh"
            echo "Skipping validation step"
          else
            sudo chmod +x deployment/validate_deployment.sh
            sudo deployment/validate_deployment.sh
          fi
          
      - name: Cleanup staging files (only on success)
        if: success()
        run: |
          echo "🧹 Cleaning up deployment staging directory..."
          sudo rm -rf /mnt/storage/deployment-staging

  notify_status:
    name: Notify Deployment Status
    runs-on: ubuntu-latest
    needs: [validate_deployment, deploy_to_pi]
    if: always()
    steps:
      - name: Deployment Success Notification
        if: needs.deploy_to_pi.result == 'success'
        run: |
          echo "✅ Traffic Monitoring System deployed successfully!"
          echo "📊 Commit: ${{ github.sha }}"
          echo "👤 Triggered by: ${{ github.actor }}"
          
      - name: Deployment Failure Notification
        if: needs.deploy_to_pi.result == 'failure' || needs.validate_deployment.result == 'failure'
        run: |
          echo "❌ Traffic Monitoring System deployment failed!"
          echo "🌐 Environment: production"
          echo "📊 Commit: ${{ github.sha }}"
          echo "👤 Triggered by: ${{ github.actor }}"
          exit 1